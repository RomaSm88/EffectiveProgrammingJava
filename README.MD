## Статья №1
### Получение экземпляра класса
1. Использовать открытый констурктор.
2. Статический фабричный  метод, который возвращает экземпляр класса.
#### Приемущества статических фабричных методов
1. Статический фабричный метод, имеет название. Тчательно подобранное название подчеркивает реализацию фабричного метода.
Рекомендации по именованию фабричных методов:
valueOf - возвращает экземпляр, который имеет тип такой же как параметр этого метода.
of - сокращенная форма от valueOf
getInstance - возвращает экземпляр описанный параметрами, но его тип может быть отличным от переданных параметров.
newInstance - каждый экземпляр возвращаемого типа будет отличаться от типов, переданных параметров.
getType - то же что и getInstance, но используется когда фабричный метод находится в бругом классе.
newType - то же что и newInstance, но используется когда фабричный метод находится в бругом классе.

2. Статический фабричный метод может иметь одинаковую сигнатуру. 
Создать несколько конструкторов с одинаковой сигнатурой нельзя.

3. Фабричный метод не обязан возвращать новый объект. Может возваращаться заранее созданый изменяемый экземпляр или
кэщированный экземпляр, который был создан ранее.
Для многих программ, данное приемущество позволяет повысить производительность.

4. Фабричный метод, может вернуть объект, который соответсвует любому подтипу, исходного класса. Таким образом,
можно вернуть тип, класс которого не объявлен как public.

#### Основной недостаток фабричных статических методов
Если класс для создания экземпляра имеет только статическийфабричный методов, то у такого класса не может быть подклассов,
что в свою очередь является и приемуществом, так как это поощряет программистов использовать компазицю, а не наследование.

## Статья №2
### Шаблон Bulder, если в конструкторе много (от 4) не обязательных параметров
Недостаток телескопического контсруктора: трудно поддерживать код, нет наглядного представления, для какой цели используется
каждый параметр констурктора.
Недостаток шаблона JavaBean (когда каждое поле класса инициализируется сеттером): в момент создания объект находится в 
неустойчивом состоянии т.к setter для полей еще не вызывались. Исключает возможность сделать класс не изменяемым.
### Приемущество использования шаблона Builder
1. Имметирует именнованные дополнительные параметры объекта.
2. У builder может быть несколько методов с переменным числом параметров.
3. Один builder может быть использован для создания нескольких объектов.
4. Автоматическое заполнение некоторых полей в момент создания объекта, например серийный номер.
### Недостатки шаблона Builder
1. Затраты процессорного времени на предварительное создание Builder. В настоящее время, недостаток менее актуален.
2. Шаблоны builder более громозки в использовании по сравнению с шаблоном - "телескопический конструктор".
3. При проектировании класса, Builder необходимо внедрять на первоначальном этапе.

## Статья №3
### Синглетон
Это класс, для которого создается объект в единственном экземпляре.
Лучший подход при реализации синглетона (singleton), использовать перечисляемый тип с одним элементом.
При использовании типа Enum, объект данного типа становится сериализуемым по умолчанию.


## Статья №4
### Закрытый конструктор для предотвращения создания экземпляра класса
Запретить создание экземпляра можно, поместив в класс единсвенный закрытый конструктор без параметров, а сам класс 
объявить как final.
Внутри такого конструктора желательно выбрасывать исключение: throw new AssertionError();
Побочный эффект: данный класс не может учавствовать в наследовании.

## Статья №5
### Не создавайте новый объект, если может быть переиспользован уже созданный
Для избежания создания дубликатов, необходимо в не изменяемом классе, использовать статический фабричный метод вместо
конструктора. Повторно могут быть использованы и изменяемые объект, если последние уже больше не будут менятя.
В Java 8, являеются устаревшими классы: Date, Calendar. Необходимо использовать классы из пакета: java.time. Классы
из этого пакета являются не изменяемыми, по этому их можно переиспользовать. Пример использования в классе Example_5.
Предпочитайте примитивные типы классам-оберткам, избегайте не преднамеренного автоупаковывания, например
Long value = 0L;
long i = 1l;
value += i (произойдет автоматическое создание еще одного объекта Long, что снизит производительность).

## Статья №6
### Уничнотожение устаревших ссыллок на объект.
1. Утечка памяти из за устаревших объектов
Если ссылка на объект устарела ее необходимо обнулить. В дальнейщем если какая либо часть программы по ошибке обратиться 
к устаревшей ссылки, будет сгенировано искючение: NullPointException, вместо некоретктного продолжения работы программы.
Обнуление ссылок на объект является не нормой, а исключением.
При обнулении ссылки на объект, сборщик мусора, понимает это действие, как необходимость освободить память, которая
была выделена под хранение объекта. При ручном обнулении ссылок, программист должен озаботиться предотвращением 
утечек памяти.
Лучший способ избавиться от устаревшей ссылки, выйти из области видимости переменной, содержащей ссылку. Значит,
для каждой переменной, следует задавать максимально ограниченную область видимости.
2. Утечка памяти в следствии использования кэша
Кэш следует переодически очищать от устаревших записей. Чистку может выполнить фоновый поток: Timer или 
ScheduledThreadPoolExecutor. Так же кэш можно чистить при добавлении в него новой записи, например методом 
removeEldestEntry из класса java.util.LinkedHashMap.

## Статья №7
### Остерегайтесь методов finalize
Методы finalize непредсказуемы. При использовании: проблемы с производительностью и переносимостью программы.
Аналог диструктора в Javа, это блок try-finally или использование блока try c ресурсами.
Если класс в котором требуется явное закрытие, должен реализовать методы интерфейса AutoClosable или Closable.

В методе finalize нельзя выполнить операции, критичные по времени, т.к невозможно предсказать когда JVM приступит
к выполнению этих методов, например если в методе finalize выполняется закрытие открытых файлов, то по факту эти
файлы могут быть открыты долгое время, что приведет в конечном счете к необосновонному переиспользованию ограниченных
ресурсов.
Спецификация языка Java, не дает гаранитии, что методы finalize будут вызваны.

Если в ходе выполнения finalize возникает исключение, оно будет не обработанным, что приведет к испорченному объекту
на выходе и если другой поток попытается воспользоваться таким объектом, результат будет не предсказуемым.
Вместо использования метода finalize, необходимо создать метод явного закрытия ресурсов: файлы, потоки, а
клиент который будет использовать объект, должен  вызывать этот метод, когда работа с объектом завершена. Метод явного
закрытия, должен делать запись в неком закрытом поле, о том что этот объект более не является действитльным. Остальные
методы класса должны проверять значение в закрытом поле и выбрасить исключение IllegalStateException, если метод был
вызван после того как объект был закрыт. Типичный пример явного закрытия - метод close в InputStream, OutputStream.
Пример аккуратного закрытия потоков: cancel из java.util.Timer

## Статья №8
### Переопределение метода equals
Если метод не переопределен, то класс будет равен только самому себе. Метод не следует переопределять, если выполняются
следующие условия:
1. Каждый экземпляр класс уникален по сушеству, например класс Thread.
2. Если в классе не предусмотрена возможность проверки логического равенства.
3. Метод equals переопределен в суперклассе.
4. Класс закрыт или доступен только в пределах пакета.
Основная цель переопределения equals, ответить на вопрос, эквиваленты ли два объекта логически.
Если тип класса, гарантирует уникальность экземпляра, то меотд equals может быть унаследован от класса Object.
Метод equals реализует отношение логической эквивалентности, он должен обладать свойствами:
1. Рефликсивность:
x = null; x.equels(x) == true
2. Симметричность: x.equals(y) == y.equals(x).
При нарушении симметричности, будет непредсказуемый результат, при взаимодействии вашего объекта со сторонним объектом.
3. Транзитивность: если для всех нулевых сссылок возвращается true то и эти ссылки должны быть равны между собой.
Не сушуствует способа расширить класс, порождающий экземпляр, и добавить к нему компанент (свойство), сохранив при этом
контракт мтеода equals.
Принцип подстановки Барбары Лисков: любое важное свойство типа, должно содержаться в его подтипе. Следовательно любой
метод написанный для типа, должен работать и на его подтипах.
Обходной способ: вместо наследования используйте компазицию, вводите в расширяемый тип закрытое поле основного типа и
предоставляйте к нему доступ, через открытый setter.
Ошибка транзитивности присутвует в классах: java.sql.Timestamp, java.util.Date. Следует использовать классы из пакета
java.time, в Java 8. Класс java.time.Instance, реализует абстракцию "момент времени", заменя оба класса Timestamp, Date.
4. Непротиворечивость: постоянность результата сравнения.
Для соблюдения этого правила, в некоторых случаях класс должен быть сделан не изменяемым.
Не ставте метод equals в зависимость от не надежных ресурсов.
5. Требование отличия от Null: x = null; x.equals(null) == false
Ни один объект не должен быть равен null.
### Рецепт создания высокочасественного метода equals
1. Использовать оператор == для проверки, является ли аргумент ссылкой на тот же объект. Если это так возвращайте true.
2. Используйте оператор instanceof для проверки, типа аргумета. Это следует делать, вместо
equals(Object x) {
    if (x == null) // не верно
    if (x instanceof Object) // верно.
}
3. Приводить аругменты к правильному типу, но только если выполнено условие №2
4. Проверить все значимые поля класса на равенство значений. Для значений простых типов, использовать при сравнении
оператор == Для полей с ссылкой на объект, рекурсвивно вызывать equals. Для полей float: Float.compare, для полей
с типом double: Double.compare. При работе с массивом, применять: Array.equals. 
Для сравнения полей, значение которых могут быть null, использовать идиому: Object.equals(a, b)
Первоначально следует сравнивать поля, которые будут отличаться с большей вероятностью или те которые будут сравниваться
максимально просто. 
5. После написание метода equals, задать вопросы: является ли метод транзитивным, непротиворечивым и симметричным и ответить
на ниъ с помошью тестов.
6. Вместе с переопределением метода equals, переопределяйте метод hashCode.
7. Объявляя метод equals, не указывайте вместо Object другой тип.

## Статья №9
### Переопределеение hashCode
Если переопределеяется метод equals, то и метод hashCode должен быть переопределен. Если метод не переопределяется, то
класс не верно работает со всеми классами, которые используют хэш-таблицы: HashMap, HashSet...
Контракт к переопределение метода hashCode
1. Неизменность значения, но значение может изменить если приложение будет перезапушено.
2. Если два объекта по мнениею equals равны, то и значения которые вернет hashCode, должны быть равны.
3. Если по мнению equals два объекта не равны, то значения hashCode не обязаны отличаться.
При вычислении хэш-кода для объекта, необходимы вычислить значения кода для значемых полей объекта.
Алгоритм для вычисления хэш-кода: (A,B, C - значемые поля объекта)
public int hashCode() {
    return objects.hash(A, B, C);
}

## Статья №10
### Переопределение метода toString
Всегда переопределяйте метод, в выводимую строку включайте значемые поля объекта. Но помнимте, что этот 
метод не является хорошей алтернативой методов get. Метод toString может быть использован 
только для отладки вашего класса.
В переопределяемый метод toString следует включать всю полезную информацию из объекта.
Форматируйте вывод метод toString, чтобы в будущем, можно было вызвав метод получить только интересующую
часть информации, а не пытаться парсить всю строку в поисках нужного.

## Сатья №11
### Метод clone
Изящный и рекомендуемый подход при копировании - создание конструктора копии или фабричного метода.
Пример констурктора копии: public Yum(Yum yum)
Пример статического фабричного метода: static Yum newInstance(Yum yum)
Вместо конкретного класса в аргументе конструктора копии и фабричного метода, может присутвовать
интерфейс. 

Для реализации метода clone, предусмотрен интрефейс Cloneable. Интерфейс не имеет методов, 
предназначен для определения поведения метода clone в классе Object. 
Метод clone из класса Object возвращает копию объекта с копированием всех полей или вернет 
исключение CloneNotSupportedException.
На практике, ожидается, что класс реализующий интерфейс Cloneable, должен иметь правильно работающий,
открытый метод clone. Это условие выполнить возможно, 
если все поля класса имеют простой тип или ссылки на не изменяемый объект и в исходном классе метод 
clone перегружен (@Override) и имеет открытый доступ к методу clone из класса Object.
пример:
@Override
public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone(); // Вызов метода clone из класса Object
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
}
Для кланирования объектов, поля в которых имеют ссылки на изменяемые объекты, 
необходимо обеспечить, чтобы метод clone, работал как конструктор и не портил оригинальный объект 
Инвариантность клона - клонированный объект содержит копию значений в своих полях, 
а не ссылки на значения из оригинального объекта.
Пример:
@Override
public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        result.elements = elements.clone(); // Клонирование изменяемого поля
        return result;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
}
Если бы поле elements было объявлена как final, то приведенный пример клонирования не сработает.
При клонирониии объектов, поля которых имеют связонные списки, необходимо использовать
глубокое копирование (deep copy). Каждый не пустой элемент списка, копируется в цикле.
Пример:
Entry deepCopy() {
    Entry result = new Entry(key, value, next); // Создаем первый элемент списка.
    for (Entry p = result; p.next != null; p = p.next)
        p.next = new Entry(p.next.key, p.next.value, p.next.next);
    return result;
}
Метод clone не должен вызвать переопределенные методы, взятых из создаваемого клона.
Переопределенные методы clone не должны быть объявлены как throws CloneNotSupportedException, 
следовательно исключение NotSupportedException в переопределенном методе, можно опустить.
Для классов, которые учавствуют в наследовании:
атрибут доступа (protected), объевление throws NotSupportedException  
и не должен реализовывать интерфейс Cloneable т.е объявление метода clone должны быть идентично 
оригиналу из Object.clone.
Для обеспечения потокобезопастности, метод clone необходимо синхронизировать.
Все классы реализующие интерфейс Cloneable должны переопределять метод clone как открытый. Этот метод
должен вызывать super.clone, а затем привести в соответвсие с оригиналом все поля.
 







 














